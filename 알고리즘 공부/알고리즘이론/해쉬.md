# 해쉬

임의의 크기를 가진 데이터를 고정된 데이터의 크기로 변환시키는 것



키를 입력받고 해쉬알고리즘을 통해 해쉬코드 만들어냄 



## 1. Direct Addressing Table

![](https://t1.daumcdn.net/cfile/tistory/2714953C570C9A8D0F)

key-value 쌍의 데이터를 배열에 저장할, key값을 직접적으로 배열의 인덱스로 사용

삭제시 해당키위치에 null값 넣어주면 됨, 저장,삭제,갱신 모두 O(1)의 시간복잡도

key값의 최대크기만큼 배열이 할당되기 때문에 공간낭비 가능성있음



## 2. Hash Table

![](https://t1.daumcdn.net/cfile/tistory/21565B36570C9C560F)

key-value 쌍에서 eky값을 테이블에 저장할 때, key값을 함수를 이용해 계산을 수행 한 후, 그 결과값을 배열의 인덱스로 사용

key값을 계산 하는 함수는 해쉬함수 라고 부름

Direct 방식보다 공간낭비가 적음, 



### 2.1 충돌(collision)

서로다른 k 값이 동일한 h(k)값을 가져 같은 slot에 저장되는 경우

#### chaining 방법 - 충돌을 허용하되 최소화 하는 방법

![](https://t1.daumcdn.net/cfile/tistory/2148DA3B570C9F5E2A)

데이터들을 포인터를 이용해 서로 체인 형태로 엮어 나가는 것

충돌이 일어나면, 그 위치에 있던 데이터에 key값을 뒤이어 연결한다.

연결리스트의 형태를 취함

수행시간은 삽입시 해쉬값을 이용해 바로 slot에 저장 상수시간, 삭제는 연결리스트의 삭제와 동일하게 상수시간, 탐색시 연결리스트를 따라 가기 때문에 리스트의 길이만큼 발생

한 slot에 모든 데이터가 들어가는 최악의 경우 연결리스트 탐색시간만큼 발생



#### 적재율

평균적인 경우 탐색시간은 O(a+1) 이다. a는 적재율을 뜻하며 현재 저장된 key값 갯수 (K), 전체 테이블의 갯수(N)을 서로 나눈 값이다. 

키값에 비해 데이터가 많으면 많을 수록 연결리스트 탐색 확률 증가



#### Simple uniform hash

충돌이 적은 해쉬함수를 방법의 조건으로 Simple uniform hash함수를 만드는것

1. 계산된 해쉬값들은 0부터 -1 사이의 범위를 동일한 확률로 골고루 나타날 것

2. 각각의 해쉬값들은 서로 연관성을 가지지 않고 독립적으로 생성될 것



#### Division method

대표적인 hash함수임, modular 연산방법을 이용.

특정 key를 어떤 수로 나눈 나머지를 해쉬값으로 사용한다.

예를들어 m=100이면 k mod m 은 0~99값을 가진다. m의 크기는 보통 키의 수의 3배가 적당하다고 함.

적재율이 30% 쯤까지 충돌이 거의 일어나지 않는다고 함





## 3. Open Addresing

모든 데이터(key+데이터)를 테이블에 저장하는 방법

포인터를 쓸일이 없어 포인터를 사용함으로서 발생 할 수 있는 오버헤드를 방지할 수 있다

포인터 접근에 필요한 시간이 필요없어 성능향상



#### liner probing

key값으로 인덱스를 계산할 때, 충돌이 발생하면 바로 다음 인덱스에 데이터를 저장하는 방식. 다음인덱스 충돌나면 또 다음 인덱스에 저장

![](https://t1.daumcdn.net/cfile/tistory/2502CB3C570CAAED16)

m의 크기는 11로 해쉬 함수는 k mod 11로 계산됨

매 충돌시마다 한칸씩 이동하므로 해쉬함수는 다음과 같은 형태를 취하게 된다.

h(k,i) = (k+i) mod m

i는 충돌시 마다 증가하여 한칸씩 이동



구현이 용이하지만, primary clustering 이라는 문제점을 가지고 있다. 즉 충동이 나면 뒤슬롯에 데이터를 넣어 하나의 데이터 덩어리를 이루기 때문에, 데이터들이 특정 위치에만 밀집하는 현상을 말한다. 이 현상으로 slot이 많아지면 많아질수록 탐색시간이 증가한다

#### Quadratic probing

이를 방지하기 위해 hash함수를 다음과 같이 2차식으로 만드는것

$h(k,i) = (h'(k)+c_1\times{i}+c_2\times{i^2}) \mod m$

한칸씩 이동하는 것이 아닌 $c_1\times{i}+c_2\times{i^2}$ 만큼 이동한다.

![](https://t1.daumcdn.net/cfile/tistory/2507BF36570CB4FA14)

하지만 Quadratic probing 에도 secondary clustering 이라는 단점이 있다. 이는 처음 시작 해쉬 값이 같을 경우, 그 이후의 해쉬값들도 모두 동일한 값으로 계산되어 충돌이 반복적으로 일어나는 것을 말한다.



#### Double hashing

문제점을 해결하기 위해 해쉬함수를 해쉬함수 2개로 구성하는 것
$$
h1(k) = k\ mod\ m_1\\
h2(k) = k\ mod\ m_2\\
h(k,i) = (h1(k)+i\times{h2(k)})\ mod\ m
$$
![](https://t1.daumcdn.net/cfile/tistory/2354D734570CB64034)

